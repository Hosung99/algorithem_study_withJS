### 이진탐색(이분탐색)
* 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법
  * 배열의 내부의 데이터가 오름차순으로 정렬되어야 사용할 수 있음

### 이진탐색(이분탐색) 과정
1. 변수 3개(left, mid, right)를 사용하여 탐색
   1. mid = left + (right - left) / 2
      1. 오버플로우 방지
      2. (left + right)가 음수일 경우 방지
   2. mid = (left + right) / 2
2. 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 것

### 종료 조건
1. 검색을 성공한 경우
   * 리스트에서 검색할 값과 같은 요소를 발견한 경우
   * Array[mid] = target
2. 검색을 실패한 경우
   * 더 이상 검색할 범위가 없을 경우
   * left > right

### 시간 복잡도
* 탐색범위를 절반씩 줄이기 때문에 O(logN)을 보장

### 배열에서의 동작방식
1. 정렬된 배열에서 중간 인덱스(mid)를 찾는다.
2. 찾으려는 값(target)과 중간 값(mid_val)을 비교한다.
3. target이 mid_val보다 작으면 mid를 기준으로 왼쪽 부분 배열을 탐색 
   
   target이 mid_val보다 크면 mid를 기준으로 오른쪽 부분 배열을 탐색
5. 탐색 범위를 반으로 줄인다.
6. 탐색 범위가 더 이상 없을 때까지 위 과정을 반복한다.
```
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    
    if (arr[mid] == target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  
  return -1;
}

const arr = [1, 2, 3, 4, 5, 6];
const target = 3;
const index = binarySearch(arr, target);
console.log(index); // 2
```

### 트리에서의 동작방식
1. 트리에서 중간 노드를 찾는다.
2. 찾으려는 값과 중간 노드의 값과를 비교한다.
3. 찾으려는 값이 중간 노드의 값보다 작으면 왼쪽 하위 트리에서 탐색 계속

   찾으려는 값이 중간 노드의 값보다 크면 오른쪽 하위 트리에서 탐색 계속
4. 탐색 범위를 반으로 좁힌다.
5. 탐색 범위가 더 이상 없을 때까지 위 과정을 반복한다.
   
![alt text](<이진탐색 트리.png>)

### 이진탐색의 장점
* 검색 속도가 빠르다
  * 검색 대상의 크기와 상관없이 빠르기 때문에 대량의 데이터를 다루는 알고리즘에서 많이 사용
* O(log N)의 검색 속도 보장
  
### 이진탐색의 단점
* 특정 구조가 필요
  * 배열이나, 이진탐색 트리와 같이 정렬된 구조에서만 사용 가능
* 검색 대상의 생성, 수정에 취약
  * 이진탐색은 탐색을 위해 추가적인 메모리를 사용하지 않기 때문에 검색 대상을계속해서 수정하거나 추가하는 경우에는 탐색 시간이 길어질 수 있음