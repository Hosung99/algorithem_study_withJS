### DP(dynamic programming, 동적 계획법)

* 어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는 방식의 알고리즘

### 메모이제이션
* 중복 계산을 피하기 위한 기법
* 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술

### DP 구현 단계
1. 문제를 하위 문제로 쪼갠다
2. 하위 문제를 재귀적으로 해결한다.
3. 결과를 저장한다. (메모이제이션)
4. 저장된 결과를 이용하여 큰 문제를 해결한다.

### 메모이제이션 구성 과정
1. 입력값에 대한 결과값을 저장할 메모이제이션 테이블을 초기화한다.
2. 함수를 호출할 때, 먼저 메모이제이션 테이블에서 해당 입력값의 결과값이 이미 저장되어 있는지 확인한다.
3. 저장되어 있으면 해당 결과값을 반환하고, 저장되어 있지 않으면 계산을 수행하고 그 결과를 메모이제이션 테이블에 저장한다.
4. 계산된 결과값을 반환한다.

### 메모제이션 테이블이란?
* 동적 계획법에서 사용되는 저장 공간
  * 이전에 계산한 값을 저장해두었다가 나중에 같은 값을 계산할 때 다시 계산하지 않고 이전에 계산한 값을 사용함으로써 계산 속도를 높일 수 있다.
* 일반적으로 해시 테이블이나 배열 등을 사용하여 구현

### DP 조건
1. 최적 부분 구조(Optimal Substructure)
   * '큰 문제의 최적해'가 '작은 문제의 최적해'를 포함한 성질
     * 작은 문제의 최적해를 구한 후 그것을 이용하여 큰 문제의 최적해를 구할 수 있다.
2. 중복 부분 문제 (Overlapping Subproblems)
   * '동일한 작은 문제를 반복적으로 해결'해야 하는 성질
     * 작은 문제를 해결할 때 반복적으로 같은 문제를 해결해야 한다.

### DP 종류
| 종류 | 특징 | 장점 | 단점 |
|---|---|---|---|
탑다운(Top-down) 방식 | 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식 | 작은 문제들의 결과값을 저장함으로써 동일한 계산을 반복하지 않아 시간 복잡도 감소한다 | 스택 오버플로우 발생 가능성이 있다.
바텀업(Bottom-up) 방식 | 작은 문제부터 차례대로 해결해 나가는 방식 | 부분 문제의 해를 저장하고 이를 활용하여 다음 문제를 해결함으로써 시간 복잡도 감소한다 | 초기값을 설정해줘야 하고, 작은 문제들의 결과값을 임시적으로 저장해 둘 공간이 필요하다

### 탑다운 방식
* 재귀적으로 호출하여 문제를 해결하는 방식
  * 재귀호출을 사용함으로써 스택 오버플로우가 발생할 수 있다.
* 큰 문제를 작은 문제로 나누어 푸는 분할정복(Divide and Conquer) 방식과 비슷하다
  * 중복되는 작은 문제들을 한 번만 푸는 것이 특징

### 바텀업 방식
* '작은 문제'부터 해결하여 '큰 문제'를 해결하는 알고리즘 방식
* 이전에 ‘계산한 부분 문제’의 결과를 저장해두고 나중에 같은 부분 문제가 나타날 때 다시 계산하지 않고 저장된 값을 사용하여 시간을 절약한다.
* 탑다운 방식과 비교하여 재귀적으로 수행하지 않고 ‘반복문’을 통하여서 문제를 해결해 나아가는 방식을 의미

### DP 활용 방법
1. 피보나치 수열
   * 이전 두 항의 합이 다음 항이 되는 수열을 의미
   * [1, 1, 2, 3, 5, 8, 13, 21, 34,...]
2. 최장 공통 수열(Longest Common Subsequence, LCS)
   * 두개의 문자열 내에서 ‘서로 다른 위치에 있는 문자들’을 비교하여 가장 긴 길이의 공통 부분 수열을 찾는다
  
    ||||||||
    |---|---|---|---|---|---|---|
    |str1|<span style="color:red">b</span>|<span style="color:red">a</span>|<span style="color:red">n</span>|a|a|<span style="color:red">n</span>|
    |str2|v|<span style="color:red">b</span>|<span style="color:red">a</span>|<span style="color:red">n</span>|k|<span style="color:red">n</span>|


3. 최종 공통 문자열(Final Common Substring, LCS)
   * 두 개의 문자열 내에서 '연속적인 부분 문자열' 중 가장 긴 길이의 공통 부분 문자열을 찾는다.

    ||||||||
    |---|---|---|---|---|---|---|
    |str1|<span style="color:red">b</span>|<span style="color:red">a</span>|<span style="color:red">n</span>|a|a|n|
    |str2|v|<span style="color:red">b</span>|<span style="color:red">a</span>|<span style="color:red">n</span>|k|n|